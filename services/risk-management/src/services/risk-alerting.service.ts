import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In, MoreThan, LessThan } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Cron, CronExpression } from '@nestjs/schedule';
import {
  RiskAlert,
  AlertType,
  AlertSeverity,
  AlertStatus,
  AlertPriority,
} from '../entities/risk-alert.entity';
import { RiskLimit } from '../entities/risk-limit.entity';
import { RiskMetrics } from '../entities/risk-metrics.entity';
import * as _ from 'lodash';

export interface AlertingRule {
  id: string;
  name: string;
  description: string;
  type: AlertType;
  severity: AlertSeverity;
  priority: AlertPriority;
  conditions: {
    metric?: string;
    operator: 'gt' | 'gte' | 'lt' | 'lte' | 'eq' | 'ne' | 'contains' | 'not_contains';
    value: any;
    timeWindow?: string;
    aggregation?: 'sum' | 'avg' | 'max' | 'min' | 'count';
  }[];
  actions: {
    type: 'notify' | 'block' | 'limit' | 'escalate' | 'custom';
    parameters: Record<string, any>;
  }[];
  channels: string[];
  cooldownMinutes: number;
  active: boolean;
  scope: 'user' | 'account' | 'portfolio' | 'global';
  targetUsers?: string[];
  targetAccounts?: string[];
}

export interface NotificationChannel {
  type: 'email' | 'sms' | 'slack' | 'webhook' | 'dashboard' | 'push';
  config: Record<string, any>;
  enabled: boolean;
}

@Injectable()
export class RiskAlertingService {
  private readonly logger = new Logger(RiskAlertingService.name);

  // In-memory cache for alerting rules (in production, this would be in Redis)
  private alertingRules: Map<string, AlertingRule> = new Map();
  private notificationChannels: Map<string, NotificationChannel> = new Map();

  constructor(
    @InjectRepository(RiskAlert)
    private readonly riskAlertRepository: Repository<RiskAlert>,
    @InjectRepository(RiskLimit)
    private readonly riskLimitRepository: Repository<RiskLimit>,
    @InjectRepository(RiskMetrics)
    private readonly riskMetricsRepository: Repository<RiskMetrics>,
    private readonly eventEmitter: EventEmitter2,
  ) {
    this.initializeDefaultRules();
    this.initializeNotificationChannels();
  }

  async createAlert(alertData: Partial<RiskAlert>): Promise<RiskAlert> {
    try {
      // Check for duplicate alerts within cooldown period
      const existingAlert = await this.findRecentSimilarAlert(alertData);
      if (existingAlert) {
        this.logger.log(`Similar alert exists within cooldown period, skipping creation`);
        return existingAlert;
      }

      const alert = this.riskAlertRepository.create({
        ...alertData,
        status: AlertStatus.ACTIVE,
        isAutoGenerated: true,
      });

      await this.riskAlertRepository.save(alert);

      // Send notifications
      await this.sendNotifications(alert);

      // Set up auto-escalation if configured
      await this.scheduleAutoEscalation(alert);

      // Emit event
      this.eventEmitter.emit('risk.alert.created', {
        alertId: alert.id,
        alertType: alert.alertType,
        severity: alert.severity,
        userId: alert.userId,
      });

      this.logger.log(`Risk alert created: ${alert.id} (${alert.alertType}, ${alert.severity})`);

      return alert;
    } catch (error) {
      this.logger.error(`Failed to create risk alert: ${error.message}`, error.stack);
      throw error;
    }
  }

  async acknowledgeAlert(alertId: string, acknowledgedBy: string, comments?: string): Promise<RiskAlert> {
    const alert = await this.riskAlertRepository.findOne({ where: { id: alertId } });
    if (!alert) {
      throw new Error('Alert not found');
    }

    alert.status = AlertStatus.ACKNOWLEDGED;
    alert.acknowledgedBy = acknowledgedBy;
    alert.acknowledgedAt = new Date();
    alert.acknowledgmentComments = comments;

    await this.riskAlertRepository.save(alert);

    // Emit event
    this.eventEmitter.emit('risk.alert.acknowledged', {
      alertId: alert.id,
      acknowledgedBy,
      previousStatus: AlertStatus.ACTIVE,
    });

    this.logger.log(`Alert acknowledged: ${alertId} by ${acknowledgedBy}`);

    return alert;
  }

  async assignAlert(alertId: string, assignedTo: string, assignedBy: string): Promise<RiskAlert> {
    const alert = await this.riskAlertRepository.findOne({ where: { id: alertId } });
    if (!alert) {
      throw new Error('Alert not found');
    }

    alert.assignedTo = assignedTo;
    alert.assignedAt = new Date();
    alert.status = AlertStatus.IN_PROGRESS;

    await this.riskAlertRepository.save(alert);

    // Send notification to assigned user
    await this.sendAssignmentNotification(alert, assignedBy);

    // Emit event
    this.eventEmitter.emit('risk.alert.assigned', {
      alertId: alert.id,
      assignedTo,
      assignedBy,
    });

    this.logger.log(`Alert assigned: ${alertId} to ${assignedTo} by ${assignedBy}`);

    return alert;
  }

  async resolveAlert(
    alertId: string,
    resolvedBy: string,
    resolutionDetails: string,
    resolutionActions: string[],
  ): Promise<RiskAlert> {
    const alert = await this.riskAlertRepository.findOne({ where: { id: alertId } });
    if (!alert) {
      throw new Error('Alert not found');
    }

    alert.status = AlertStatus.RESOLVED;
    alert.resolvedBy = resolvedBy;
    alert.resolvedAt = new Date();
    alert.resolutionDetails = resolutionDetails;
    alert.resolutionActions = resolutionActions;

    await this.riskAlertRepository.save(alert);

    // Emit event
    this.eventEmitter.emit('risk.alert.resolved', {
      alertId: alert.id,
      resolvedBy,
      resolutionTime: alert.resolvedAt.getTime() - alert.createdAt.getTime(),
    });

    this.logger.log(`Alert resolved: ${alertId} by ${resolvedBy}`);

    return alert;
  }

  async escalateAlert(alertId: string, escalatedBy: string, reason?: string): Promise<RiskAlert> {
    const alert = await this.riskAlertRepository.findOne({ where: { id: alertId } });
    if (!alert) {
      throw new Error('Alert not found');
    }

    alert.status = AlertStatus.ESCALATED;
    alert.isEscalated = true;
    alert.escalatedAt = new Date();

    // Increase severity if not already at maximum
    if (alert.severity !== AlertSeverity.EMERGENCY) {
      alert.severity = this.getNextSeverityLevel(alert.severity);
    }

    // Upgrade priority
    alert.priority = AlertPriority.P1;

    await this.riskAlertRepository.save(alert);

    // Send escalation notifications
    await this.sendEscalationNotifications(alert, escalatedBy, reason);

    // Emit event
    this.eventEmitter.emit('risk.alert.escalated', {
      alertId: alert.id,
      escalatedBy,
      newSeverity: alert.severity,
      reason,
    });

    this.logger.log(`Alert escalated: ${alertId} by ${escalatedBy}, new severity: ${alert.severity}`);

    return alert;
  }

  async getActiveAlerts(filters?: {
    userId?: string;
    accountId?: string;
    alertType?: AlertType;
    severity?: AlertSeverity;
    priority?: AlertPriority;
    limit?: number;
  }): Promise<RiskAlert[]> {
    const queryBuilder = this.riskAlertRepository
      .createQueryBuilder('alert')
      .where('alert.status IN (:...activeStatuses)', {
        activeStatuses: [AlertStatus.ACTIVE, AlertStatus.ACKNOWLEDGED, AlertStatus.IN_PROGRESS],
      });

    if (filters?.userId) {
      queryBuilder.andWhere('alert.userId = :userId', { userId: filters.userId });
    }

    if (filters?.accountId) {
      queryBuilder.andWhere('alert.accountId = :accountId', { accountId: filters.accountId });
    }

    if (filters?.alertType) {
      queryBuilder.andWhere('alert.alertType = :alertType', { alertType: filters.alertType });
    }

    if (filters?.severity) {
      queryBuilder.andWhere('alert.severity = :severity', { severity: filters.severity });
    }

    if (filters?.priority) {
      queryBuilder.andWhere('alert.priority = :priority', { priority: filters.priority });
    }

    queryBuilder
      .orderBy('alert.priority', 'ASC')
      .addOrderBy('alert.severity', 'DESC')
      .addOrderBy('alert.createdAt', 'DESC')
      .take(filters?.limit || 100);

    return queryBuilder.getMany();
  }

  async getAlertStatistics(timeRange: { from: Date; to: Date }): Promise<{
    totalAlerts: number;
    alertsByType: Record<AlertType, number>;
    alertsBySeverity: Record<AlertSeverity, number>;
    alertsByStatus: Record<AlertStatus, number>;
    avgResolutionTime: number;
    escalationRate: number;
  }> {
    const alerts = await this.riskAlertRepository.find({
      where: {
        createdAt: MoreThan(timeRange.from),
      },
    });

    const stats = {
      totalAlerts: alerts.length,
      alertsByType: {} as Record<AlertType, number>,
      alertsBySeverity: {} as Record<AlertSeverity, number>,
      alertsByStatus: {} as Record<AlertStatus, number>,
      avgResolutionTime: 0,
      escalationRate: 0,
    };

    // Initialize counters
    Object.values(AlertType).forEach(type => { stats.alertsByType[type] = 0; });
    Object.values(AlertSeverity).forEach(severity => { stats.alertsBySeverity[severity] = 0; });
    Object.values(AlertStatus).forEach(status => { stats.alertsByStatus[status] = 0; });

    let totalResolutionTime = 0;
    let resolvedAlerts = 0;
    let escalatedAlerts = 0;

    for (const alert of alerts) {
      stats.alertsByType[alert.alertType]++;
      stats.alertsBySeverity[alert.severity]++;
      stats.alertsByStatus[alert.status]++;

      if (alert.isEscalated) {
        escalatedAlerts++;
      }

      if (alert.status === AlertStatus.RESOLVED && alert.resolvedAt) {
        resolvedAlerts++;
        totalResolutionTime += alert.resolvedAt.getTime() - alert.createdAt.getTime();
      }
    }

    stats.avgResolutionTime = resolvedAlerts > 0 ? totalResolutionTime / resolvedAlerts : 0;
    stats.escalationRate = alerts.length > 0 ? escalatedAlerts / alerts.length : 0;

    return stats;
  }

  async createAlertingRule(rule: Omit<AlertingRule, 'id'>): Promise<AlertingRule> {
    const ruleWithId: AlertingRule = {
      ...rule,
      id: `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    };

    this.alertingRules.set(ruleWithId.id, ruleWithId);

    this.logger.log(`Alerting rule created: ${ruleWithId.id} (${ruleWithId.name})`);

    return ruleWithId;
  }

  async updateAlertingRule(ruleId: string, updates: Partial<AlertingRule>): Promise<AlertingRule> {
    const rule = this.alertingRules.get(ruleId);
    if (!rule) {
      throw new Error('Alerting rule not found');
    }

    const updatedRule = { ...rule, ...updates };
    this.alertingRules.set(ruleId, updatedRule);

    this.logger.log(`Alerting rule updated: ${ruleId}`);

    return updatedRule;
  }

  async deleteAlertingRule(ruleId: string): Promise<void> {
    if (!this.alertingRules.has(ruleId)) {
      throw new Error('Alerting rule not found');
    }

    this.alertingRules.delete(ruleId);
    this.logger.log(`Alerting rule deleted: ${ruleId}`);
  }

  async getAlertingRules(): Promise<AlertingRule[]> {
    return Array.from(this.alertingRules.values());
  }

  @Cron(CronExpression.EVERY_MINUTE)
  async evaluateAlertingRules(): Promise<void> {
    try {
      const activeRules = Array.from(this.alertingRules.values()).filter(rule => rule.active);
      
      for (const rule of activeRules) {
        await this.evaluateRule(rule);
      }
    } catch (error) {
      this.logger.error('Error evaluating alerting rules:', error);
    }
  }

  @Cron(CronExpression.EVERY_10_MINUTES)
  async checkAutoEscalation(): Promise<void> {
    try {
      const alerts = await this.riskAlertRepository.find({
        where: {
          status: In([AlertStatus.ACTIVE, AlertStatus.ACKNOWLEDGED]),
          isEscalated: false,
        },
      });

      for (const alert of alerts) {
        if (alert.escalationRules && this.shouldAutoEscalate(alert)) {
          await this.escalateAlert(alert.id, 'system', 'Auto-escalation due to timeout');
        }
      }
    } catch (error) {
      this.logger.error('Error checking auto-escalation:', error);
    }
  }

  @Cron(CronExpression.EVERY_HOUR)
  async cleanupExpiredAlerts(): Promise<void> {
    try {
      const expiredAlerts = await this.riskAlertRepository.find({
        where: {
          expiresAt: LessThan(new Date()),
          status: In([AlertStatus.ACTIVE, AlertStatus.ACKNOWLEDGED]),
        },
      });

      for (const alert of expiredAlerts) {
        alert.status = AlertStatus.EXPIRED;
        await this.riskAlertRepository.save(alert);
      }

      if (expiredAlerts.length > 0) {
        this.logger.log(`Cleaned up ${expiredAlerts.length} expired alerts`);
      }
    } catch (error) {
      this.logger.error('Error cleaning up expired alerts:', error);
    }
  }

  private async evaluateRule(rule: AlertingRule): Promise<void> {
    try {
      // Check cooldown
      const recentAlert = await this.findRecentAlertForRule(rule);
      if (recentAlert) {
        return;
      }

      // Evaluate conditions
      const conditionsMet = await this.evaluateConditions(rule.conditions);
      if (!conditionsMet) {
        return;
      }

      // Create alert
      const alertData: Partial<RiskAlert> = {
        alertType: rule.type,
        severity: rule.severity,
        priority: rule.priority,
        title: rule.name,
        description: rule.description,
        triggerConditions: {
          rule: rule.id,
          threshold: rule.conditions[0]?.value,
          actualValue: 'evaluated_value', // Would be filled with actual evaluation result
          operator: rule.conditions[0]?.operator || 'gt',
          timeWindow: rule.conditions[0]?.timeWindow || 'immediate',
        },
        recommendedActions: [],
        automaticActions: rule.actions.filter(a => a.type !== 'notify').map(a => a.type),
        notificationChannels: rule.channels,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours default
      };

      await this.createAlert(alertData);

      // Execute actions
      for (const action of rule.actions) {
        await this.executeAction(action, rule);
      }
    } catch (error) {
      this.logger.error(`Error evaluating rule ${rule.id}:`, error);
    }
  }

  private async evaluateConditions(conditions: AlertingRule['conditions']): Promise<boolean> {
    // This would evaluate the actual conditions against metrics/limits
    // For now, return false as a placeholder
    return false;
  }

  private async executeAction(action: AlertingRule['actions'][0], rule: AlertingRule): Promise<void> {
    switch (action.type) {
      case 'notify':
        // Notification is handled in createAlert
        break;
      case 'block':
        this.logger.log(`Executing block action for rule ${rule.id}`);
        // Would integrate with trading service to block trades
        break;
      case 'limit':
        this.logger.log(`Executing limit action for rule ${rule.id}`);
        // Would update risk limits
        break;
      case 'escalate':
        this.logger.log(`Executing escalate action for rule ${rule.id}`);
        // Would escalate to specific personnel
        break;
      case 'custom':
        this.logger.log(`Executing custom action for rule ${rule.id}:`, action.parameters);
        break;
    }
  }

  private async sendNotifications(alert: RiskAlert): Promise<void> {
    for (const channelType of alert.notificationChannels) {
      try {
        await this.sendNotification(channelType, alert);
      } catch (error) {
        this.logger.error(`Failed to send notification via ${channelType}:`, error);
      }
    }
  }

  private async sendNotification(channelType: string, alert: RiskAlert): Promise<void> {
    const channel = this.notificationChannels.get(channelType);
    if (!channel || !channel.enabled) {
      return;
    }

    switch (channel.type) {
      case 'email':
        await this.sendEmailNotification(alert, channel.config);
        break;
      case 'sms':
        await this.sendSMSNotification(alert, channel.config);
        break;
      case 'slack':
        await this.sendSlackNotification(alert, channel.config);
        break;
      case 'webhook':
        await this.sendWebhookNotification(alert, channel.config);
        break;
      case 'dashboard':
        await this.sendDashboardNotification(alert);
        break;
      case 'push':
        await this.sendPushNotification(alert, channel.config);
        break;
    }
  }

  private async sendEmailNotification(alert: RiskAlert, config: any): Promise<void> {
    // Integration with email service would go here
    this.logger.log(`Sending email notification for alert ${alert.id}`);
  }

  private async sendSMSNotification(alert: RiskAlert, config: any): Promise<void> {
    // Integration with SMS service would go here
    this.logger.log(`Sending SMS notification for alert ${alert.id}`);
  }

  private async sendSlackNotification(alert: RiskAlert, config: any): Promise<void> {
    // Integration with Slack would go here
    this.logger.log(`Sending Slack notification for alert ${alert.id}`);
  }

  private async sendWebhookNotification(alert: RiskAlert, config: any): Promise<void> {
    // HTTP webhook call would go here
    this.logger.log(`Sending webhook notification for alert ${alert.id}`);
  }

  private async sendDashboardNotification(alert: RiskAlert): Promise<void> {
    // Real-time dashboard update would go here
    this.eventEmitter.emit('dashboard.alert.created', alert);
  }

  private async sendPushNotification(alert: RiskAlert, config: any): Promise<void> {
    // Push notification service integration would go here
    this.logger.log(`Sending push notification for alert ${alert.id}`);
  }

  private async sendAssignmentNotification(alert: RiskAlert, assignedBy: string): Promise<void> {
    this.logger.log(`Sending assignment notification for alert ${alert.id} to ${alert.assignedTo}`);
    // Would send notification to the assigned person
  }

  private async sendEscalationNotifications(alert: RiskAlert, escalatedBy: string, reason?: string): Promise<void> {
    this.logger.log(`Sending escalation notifications for alert ${alert.id}`);
    // Would send notifications to higher-level personnel
  }

  private async findRecentSimilarAlert(alertData: Partial<RiskAlert>): Promise<RiskAlert | null> {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    
    return this.riskAlertRepository.findOne({
      where: {
        userId: alertData.userId,
        alertType: alertData.alertType,
        createdAt: MoreThan(oneHourAgo),
      },
      order: { createdAt: 'DESC' },
    });
  }

  private async findRecentAlertForRule(rule: AlertingRule): Promise<RiskAlert | null> {
    const cooldownTime = new Date(Date.now() - rule.cooldownMinutes * 60 * 1000);
    
    return this.riskAlertRepository.findOne({
      where: {
        triggerConditions: { rule: rule.id } as any,
        createdAt: MoreThan(cooldownTime),
      },
      order: { createdAt: 'DESC' },
    });
  }

  private async scheduleAutoEscalation(alert: RiskAlert): Promise<void> {
    if (alert.escalationRules?.escalateAfterMinutes) {
      // In a real implementation, this would schedule a job to escalate the alert
      this.logger.log(`Scheduled auto-escalation for alert ${alert.id} in ${alert.escalationRules.escalateAfterMinutes} minutes`);
    }
  }

  private shouldAutoEscalate(alert: RiskAlert): boolean {
    if (!alert.escalationRules?.escalateAfterMinutes) {
      return false;
    }

    const escalationTime = new Date(
      alert.createdAt.getTime() + alert.escalationRules.escalateAfterMinutes * 60 * 1000
    );

    return new Date() > escalationTime;
  }

  private getNextSeverityLevel(currentSeverity: AlertSeverity): AlertSeverity {
    const severityOrder = [
      AlertSeverity.INFO,
      AlertSeverity.LOW,
      AlertSeverity.MEDIUM,
      AlertSeverity.HIGH,
      AlertSeverity.CRITICAL,
      AlertSeverity.EMERGENCY,
    ];

    const currentIndex = severityOrder.indexOf(currentSeverity);
    return severityOrder[Math.min(currentIndex + 1, severityOrder.length - 1)];
  }

  private initializeDefaultRules(): void {
    // Default alerting rules
    const defaultRules: AlertingRule[] = [
      {
        id: 'var_breach_rule',
        name: 'VaR Limit Breach',
        description: 'Alert when Value at Risk exceeds limits',
        type: AlertType.VAR_BREACH,
        severity: AlertSeverity.HIGH,
        priority: AlertPriority.P2,
        conditions: [
          {
            metric: 'value_at_risk_95',
            operator: 'gt',
            value: 100000,
            timeWindow: '1d',
          },
        ],
        actions: [
          { type: 'notify', parameters: {} },
          { type: 'limit', parameters: { reducePositionSize: true } },
        ],
        channels: ['email', 'dashboard'],
        cooldownMinutes: 60,
        active: true,
        scope: 'portfolio',
      },
      {
        id: 'high_leverage_rule',
        name: 'High Leverage Alert',
        description: 'Alert when leverage exceeds safe limits',
        type: AlertType.RISK_LIMIT_BREACH,
        severity: AlertSeverity.MEDIUM,
        priority: AlertPriority.P3,
        conditions: [
          {
            metric: 'leverage_ratio',
            operator: 'gt',
            value: 10,
          },
        ],
        actions: [
          { type: 'notify', parameters: {} },
        ],
        channels: ['dashboard'],
        cooldownMinutes: 30,
        active: true,
        scope: 'account',
      },
    ];

    for (const rule of defaultRules) {
      this.alertingRules.set(rule.id, rule);
    }

    this.logger.log(`Initialized ${defaultRules.length} default alerting rules`);
  }

  private initializeNotificationChannels(): void {
    const channels: Array<[string, NotificationChannel]> = [
      ['email', { type: 'email', config: {}, enabled: true }],
      ['sms', { type: 'sms', config: {}, enabled: true }],
      ['slack', { type: 'slack', config: {}, enabled: true }],
      ['webhook', { type: 'webhook', config: {}, enabled: true }],
      ['dashboard', { type: 'dashboard', config: {}, enabled: true }],
      ['push', { type: 'push', config: {}, enabled: true }],
    ];

    for (const [name, channel] of channels) {
      this.notificationChannels.set(name, channel);
    }

    this.logger.log(`Initialized ${channels.length} notification channels`);
  }
}