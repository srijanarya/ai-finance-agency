#!/bin/bash

# B-MAD PARTY DEPLOYMENT SCRIPT
# AI Finance Agency - Production Deployment Coordinator
# Generated by multi-agent-coordinator

set -e

echo "ðŸŽ‰ B-MAD PARTY MODE: AI FINANCE AGENCY DEPLOYMENT ðŸŽ‰"
echo "================================================="

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

error() {
    echo -e "${RED}âŒ $1${NC}"
    exit 1
}

# Check prerequisites
check_prerequisites() {
    log "Checking prerequisites..."
    
    command -v docker >/dev/null 2>&1 || error "Docker is not installed"
    command -v docker-compose >/dev/null 2>&1 || error "Docker Compose is not installed"
    
    if [ ! -f ".env" ]; then
        warning ".env file not found, using defaults"
    fi
    
    success "Prerequisites checked"
}

# Create required directories
setup_directories() {
    log "Setting up data directories..."
    
    mkdir -p data/{postgres,redis,rabbitmq,mongodb,consul}
    mkdir -p data/{prometheus,grafana,elasticsearch}
    mkdir -p logs/{services,infrastructure,monitoring}
    
    success "Directories created"
}

# PHASE 1: Infrastructure Foundation
deploy_infrastructure() {
    log "ðŸ—ï¸  PHASE 1: Infrastructure Foundation"
    echo "======================================="
    
    log "Starting core infrastructure services..."
    docker-compose --profile infrastructure up -d postgres redis rabbitmq mongodb consul
    
    log "Waiting for services to be healthy..."
    sleep 30
    
    # Health checks
    log "Performing health checks..."
    
    # PostgreSQL
    if docker exec ai_finance_postgres pg_isready -U ai_finance_user >/dev/null 2>&1; then
        success "PostgreSQL is healthy"
    else
        error "PostgreSQL failed to start"
    fi
    
    # Redis
    if docker exec ai_finance_redis redis-cli ping | grep -q PONG; then
        success "Redis is healthy"
    else
        error "Redis failed to start"
    fi
    
    # RabbitMQ
    if curl -f http://localhost:15672/api/overview >/dev/null 2>&1; then
        success "RabbitMQ is healthy"
    else
        warning "RabbitMQ management UI not yet accessible"
    fi
    
    success "Infrastructure foundation completed"
}

# PHASE 2: Microservices Deployment
deploy_microservices() {
    log "ðŸš€ PHASE 2: Microservices Deployment"
    echo "===================================="
    
    # TIER 1: Foundation Services
    log "Deploying TIER 1: Foundation Services"
    docker-compose up -d user-management market-data
    sleep 20
    
    # TIER 2: Business Logic
    log "Deploying TIER 2: Business Logic"
    docker-compose up -d api-gateway
    sleep 15
    docker-compose up -d trading payment risk-management
    sleep 20
    
    # TIER 3: AI & Content Services
    log "Deploying TIER 3: AI & Content Services"
    docker-compose up -d signals content-intelligence education
    sleep 20
    
    # TIER 4: Communication Layer
    log "Deploying TIER 4: Communication Layer"
    docker-compose up -d notification
    sleep 15
    
    # Health validation
    log "Validating microservices health..."
    services=(
        "user-management:3002"
        "market-data:3008"
        "api-gateway:3000"
        "trading:3004"
        "payment:3001"
        "risk-management:3007"
        "signals:3003"
        "content-intelligence:3009"
        "education:3005"
        "notification:3006"
    )
    
    for service_port in "${services[@]}"; do
        service=$(echo $service_port | cut -d: -f1)
        port=$(echo $service_port | cut -d: -f2)
        
        if curl -f http://localhost:$port/health >/dev/null 2>&1; then
            success "$service is healthy"
        else
            warning "$service health check failed"
        fi
    done
    
    success "Microservices deployment completed"
}

# PHASE 3: Production Hardening
deploy_production_services() {
    log "ðŸ”’ PHASE 3: Production Hardening"
    echo "================================"
    
    # Monitoring stack
    log "Starting monitoring services..."
    docker-compose --profile monitoring up -d prometheus grafana jaeger
    sleep 30
    
    # Background processing
    log "Starting background services..."
    docker-compose up -d worker scheduler
    sleep 15
    
    # Load balancer (if production profile)
    if [ "$NODE_ENV" = "production" ]; then
        log "Starting load balancer..."
        docker-compose --profile production up -d nginx
        sleep 10
    fi
    
    success "Production hardening completed"
}

# Generate service status report
generate_status_report() {
    log "ðŸ“Š Generating service status report..."
    
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
    
    cat > service-status-report.json << EOF
{
  "timestamp": "$timestamp",
  "deployment": "bmad-party-mode",
  "results": {
    "infrastructure": {
EOF

    # Infrastructure status
    for service in postgres redis rabbitmq mongodb consul; do
        status=$(docker ps --filter "name=ai_finance_$service" --format "{{.Status}}" | head -1)
        if [ -n "$status" ]; then
            echo "      \"$service\": { \"status\": \"running\", \"details\": \"$status\" }," >> service-status-report.json
        else
            echo "      \"$service\": { \"status\": \"stopped\" }," >> service-status-report.json
        fi
    done

    cat >> service-status-report.json << EOF
    },
    "microservices": {
EOF

    # Microservices status
    services=(
        "api-gateway:3000"
        "user-management:3002"
        "payment:3001"
        "trading:3004"
        "signals:3003"
        "market-data:3008"
        "risk-management:3007"
        "education:3005"
        "notification:3006"
        "content-intelligence:3009"
    )
    
    for service_port in "${services[@]}"; do
        service=$(echo $service_port | cut -d: -f1)
        port=$(echo $service_port | cut -d: -f2)
        
        if curl -f http://localhost:$port/health >/dev/null 2>&1; then
            response_time=$(curl -o /dev/null -s -w "%{time_total}" http://localhost:$port/health)
            response_time_ms=$(echo "$response_time * 1000" | bc)
            echo "      \"$service\": { \"status\": \"healthy\", \"port\": $port, \"responseTime\": ${response_time_ms%.*} }," >> service-status-report.json
        else
            echo "      \"$service\": { \"status\": \"unhealthy\", \"port\": $port }," >> service-status-report.json
        fi
    done

    cat >> service-status-report.json << EOF
    },
    "monitoring": {
      "prometheus": "http://localhost:9090",
      "grafana": "http://localhost:3001",
      "jaeger": "http://localhost:16686"
    }
  },
  "integrationTestReady": true,
  "nextSteps": [
    "Run integration tests",
    "Configure SSL certificates",
    "Set up production secrets",
    "Configure monitoring alerts"
  ]
}
EOF

    success "Status report generated: service-status-report.json"
}

# Main deployment function
main() {
    log "Starting B-MAD Party deployment..."
    
    check_prerequisites
    setup_directories
    deploy_infrastructure
    deploy_microservices
    deploy_production_services
    generate_status_report
    
    echo ""
    echo "ðŸŽ‰ B-MAD PARTY DEPLOYMENT COMPLETED! ðŸŽ‰"
    echo "======================================="
    echo ""
    echo "ðŸ”— ACCESS POINTS:"
    echo "  â€¢ API Gateway: http://localhost:3000"
    echo "  â€¢ Trading Dashboard: http://localhost:3000/dashboard"
    echo "  â€¢ Admin Panel: http://localhost:3000/admin"
    echo "  â€¢ Grafana: http://localhost:3001 (admin/admin123)"
    echo "  â€¢ Prometheus: http://localhost:9090"
    echo "  â€¢ RabbitMQ: http://localhost:15672"
    echo ""
    echo "ðŸ“Š MONITORING:"
    echo "  â€¢ Service Status: cat service-status-report.json"
    echo "  â€¢ Health Check: curl http://localhost:3000/health"
    echo "  â€¢ Logs: docker-compose logs -f [service-name]"
    echo ""
    echo "ðŸš€ Ready for integration testing and production deployment!"
}

# Execute main function
main "$@"