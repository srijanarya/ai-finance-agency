import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { ConfigService } from '@nestjs/config';
import { DeviceTrackingService } from '../services/device-tracking.service';
import { AuditService } from '../services/audit.service';
import { AuditAction } from '../entities/audit-log.entity';
import * as rateLimit from 'express-rate-limit';
import * as slowDown from 'express-slow-down';

interface SecurityRequest extends Request {
  deviceFingerprint?: any;
  riskScore?: number;
  isBlocked?: boolean;
  securityFlags?: string[];
}

@Injectable()
export class SecurityMiddleware implements NestMiddleware {
  private readonly logger = new Logger(SecurityMiddleware.name);
  private readonly rateLimiters = new Map<string, any>();

  constructor(
    private configService: ConfigService,
    private deviceTracking: DeviceTrackingService,
    private auditService: AuditService,
  ) {
    this.initializeRateLimiters();
  }

  private initializeRateLimiters() {
    // Authentication endpoints - stricter limits
    this.rateLimiters.set('auth', rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 5, // 5 attempts per window
      message: {
        error: 'Too many authentication attempts',
        retryAfter: '15 minutes',
      },
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req: Request) => {
        return `auth_${req.ip}_${req.get('User-Agent')}`;
      },
      handler: (req: SecurityRequest, res: Response) => {
        this.handleRateLimitExceeded(req, res, 'authentication');
      },
    }));\n\n    // Password reset - very strict\n    this.rateLimiters.set('password-reset', rateLimit({\n      windowMs: 60 * 60 * 1000, // 1 hour\n      max: 3, // 3 attempts per hour\n      message: {\n        error: 'Too many password reset attempts',\n        retryAfter: '1 hour',\n      },\n      keyGenerator: (req: Request) => {\n        const email = req.body?.email || 'unknown';\n        return `pwd_reset_${req.ip}_${email}`;\n      },\n      handler: (req: SecurityRequest, res: Response) => {\n        this.handleRateLimitExceeded(req, res, 'password-reset');\n      },\n    }));\n\n    // MFA attempts\n    this.rateLimiters.set('mfa', rateLimit({\n      windowMs: 10 * 60 * 1000, // 10 minutes\n      max: 10, // 10 attempts per window\n      message: {\n        error: 'Too many MFA attempts',\n        retryAfter: '10 minutes',\n      },\n      keyGenerator: (req: Request) => {\n        return `mfa_${req.ip}_${req.get('User-Agent')}`;\n      },\n      handler: (req: SecurityRequest, res: Response) => {\n        this.handleRateLimitExceeded(req, res, 'mfa');\n      },\n    }));\n\n    // General API endpoints\n    this.rateLimiters.set('api', rateLimit({\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      max: 100, // 100 requests per window\n      message: {\n        error: 'Too many API requests',\n        retryAfter: '15 minutes',\n      },\n      keyGenerator: (req: Request) => {\n        return `api_${req.ip}`;\n      },\n    }));\n\n    // Slow down middleware for authentication\n    this.rateLimiters.set('slowdown', slowDown({\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      delayAfter: 2, // allow 2 requests per window at full speed\n      delayMs: 500, // slow down by 500ms per request after delayAfter\n      maxDelayMs: 20000, // maximum delay of 20 seconds\n      keyGenerator: (req: Request) => {\n        return `slowdown_${req.ip}_${req.get('User-Agent')}`;\n      },\n    }));\n  }\n\n  async use(req: SecurityRequest, res: Response, next: NextFunction) {\n    const startTime = Date.now();\n    \n    try {\n      // Skip security checks for health checks\n      if (req.path.includes('/health') || req.path.includes('/metrics')) {\n        return next();\n      }\n\n      // Apply appropriate rate limiting based on endpoint\n      await this.applyRateLimit(req, res);\n      \n      if (res.headersSent) {\n        return; // Rate limit was exceeded\n      }\n\n      // Generate device fingerprint\n      const fingerprint = await this.deviceTracking.analyzeDeviceFingerprint(\n        req.get('User-Agent') || 'Unknown',\n        req.ip || 'Unknown',\n        {\n          timezone: req.get('X-Timezone'),\n          language: req.get('Accept-Language'),\n          screenResolution: req.get('X-Screen-Resolution'),\n        },\n      );\n\n      req.deviceFingerprint = fingerprint;\n      req.riskScore = fingerprint.riskScore;\n      req.securityFlags = [];\n\n      // Check for high-risk requests\n      if (fingerprint.riskScore >= 80) {\n        req.securityFlags.push('HIGH_RISK');\n        await this.handleHighRiskRequest(req, res);\n        if (res.headersSent) return;\n      }\n\n      // Check for suspicious patterns\n      await this.detectSuspiciousPatterns(req);\n\n      // Add security headers\n      this.addSecurityHeaders(res);\n\n      // Log the request\n      this.logSecurityEvent(req, fingerprint);\n\n      next();\n    } catch (error) {\n      this.logger.error(`Security middleware error: ${error.message}`, error.stack);\n      next(); // Continue processing even if security check fails\n    } finally {\n      const processingTime = Date.now() - startTime;\n      if (processingTime > 1000) {\n        this.logger.warn(`Slow security processing: ${processingTime}ms for ${req.path}`);\n      }\n    }\n  }\n\n  private async applyRateLimit(req: SecurityRequest, res: Response): Promise<void> {\n    return new Promise((resolve) => {\n      let limiterType = 'api';\n      \n      if (req.path.includes('/auth/login') || req.path.includes('/auth/register')) {\n        limiterType = 'auth';\n      } else if (req.path.includes('/auth/forgot-password') || req.path.includes('/auth/reset-password')) {\n        limiterType = 'password-reset';\n      } else if (req.path.includes('/auth/mfa')) {\n        limiterType = 'mfa';\n      }\n\n      const limiter = this.rateLimiters.get(limiterType);\n      if (limiter) {\n        limiter(req, res, resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  private async handleRateLimitExceeded(\n    req: SecurityRequest,\n    res: Response,\n    type: string,\n  ): Promise<void> {\n    const ipAddress = req.ip || 'Unknown';\n    const userAgent = req.get('User-Agent') || 'Unknown';\n\n    await this.auditService.log({\n      action: AuditAction.API_RATE_LIMITED,\n      resource: 'security',\n      level: 'medium',\n      description: `Rate limit exceeded for ${type}`,\n      details: {\n        endpoint: req.path,\n        method: req.method,\n        type,\n        userAgent,\n      },\n      ipAddress,\n    });\n\n    res.status(429).json({\n      error: 'Too many requests',\n      message: `Rate limit exceeded for ${type}`,\n      retryAfter: this.getRateLimitWindow(type),\n    });\n  }\n\n  private getRateLimitWindow(type: string): string {\n    const windows = {\n      'auth': '15 minutes',\n      'password-reset': '1 hour',\n      'mfa': '10 minutes',\n      'api': '15 minutes',\n    };\n    return windows[type] || '15 minutes';\n  }\n\n  private async handleHighRiskRequest(\n    req: SecurityRequest,\n    res: Response,\n  ): Promise<void> {\n    const fingerprint = req.deviceFingerprint;\n    \n    // Block extremely high-risk requests (score >= 90)\n    if (fingerprint.riskScore >= 90) {\n      req.isBlocked = true;\n      \n      await this.auditService.log({\n        action: AuditAction.SECURITY_ALERT,\n        resource: 'security',\n        level: 'critical',\n        description: `High-risk request blocked (score: ${fingerprint.riskScore})`,\n        details: {\n          riskScore: fingerprint.riskScore,\n          fingerprint,\n          endpoint: req.path,\n        },\n        ipAddress: req.ip,\n      });\n\n      res.status(403).json({\n        error: 'Access denied',\n        message: 'Request blocked due to security concerns',\n        requestId: this.generateRequestId(),\n      });\n      return;\n    }\n\n    // Add additional verification for high-risk requests\n    if (fingerprint.riskScore >= 80) {\n      req.securityFlags.push('REQUIRES_ADDITIONAL_VERIFICATION');\n      \n      // For authentication endpoints, we might require additional verification\n      if (req.path.includes('/auth/')) {\n        res.setHeader('X-Security-Challenge', 'required');\n      }\n    }\n  }\n\n  private async detectSuspiciousPatterns(req: SecurityRequest): Promise<void> {\n    const userAgent = req.get('User-Agent') || '';\n    const referer = req.get('Referer') || '';\n    \n    // Check for bot-like behavior\n    const botIndicators = ['bot', 'crawler', 'spider', 'scraper', 'headless'];\n    if (botIndicators.some(indicator => userAgent.toLowerCase().includes(indicator))) {\n      req.securityFlags.push('BOT_LIKE_BEHAVIOR');\n    }\n\n    // Check for missing common headers\n    if (!req.get('Accept') || !req.get('Accept-Language')) {\n      req.securityFlags.push('MISSING_HEADERS');\n    }\n\n    // Check for suspicious referers\n    const suspiciousReferers = ['bit.ly', 't.co', 'tinyurl.com'];\n    if (suspiciousReferers.some(domain => referer.includes(domain))) {\n      req.securityFlags.push('SUSPICIOUS_REFERER');\n    }\n\n    // Check for unusual request patterns\n    if (req.method === 'POST' && !req.get('Content-Type')) {\n      req.securityFlags.push('UNUSUAL_REQUEST_PATTERN');\n    }\n  }\n\n  private addSecurityHeaders(res: Response): void {\n    // Security headers\n    res.setHeader('X-Content-Type-Options', 'nosniff');\n    res.setHeader('X-Frame-Options', 'DENY');\n    res.setHeader('X-XSS-Protection', '1; mode=block');\n    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n    res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n    \n    // HSTS header for HTTPS\n    if (this.configService.get('NODE_ENV') === 'production') {\n      res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n    }\n  }\n\n  private async logSecurityEvent(req: SecurityRequest, fingerprint: any): Promise<void> {\n    // Only log high-risk or flagged requests to avoid spam\n    if (fingerprint.riskScore >= 50 || req.securityFlags.length > 0) {\n      await this.auditService.log({\n        action: AuditAction.API_REQUEST,\n        resource: 'security',\n        level: fingerprint.riskScore >= 70 ? 'high' : 'medium',\n        description: 'Security-flagged request processed',\n        details: {\n          riskScore: fingerprint.riskScore,\n          flags: req.securityFlags,\n          endpoint: req.path,\n          method: req.method,\n          fingerprint: {\n            browser: fingerprint.browserInfo?.name,\n            os: fingerprint.osInfo?.name,\n            location: fingerprint.location,\n          },\n        },\n        ipAddress: req.ip,\n        userAgent: req.get('User-Agent'),\n      });\n    }\n  }\n\n  private generateRequestId(): string {\n    return Math.random().toString(36).substring(2, 15) + \n           Math.random().toString(36).substring(2, 15);\n  }\n}"}